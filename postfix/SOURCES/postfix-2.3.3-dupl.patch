 20070520
 
 	Bugfix (problem introduced Postfix 2.3): when DSN support
 	was introduced it broke "agressive" recipient duplicate
 	elimination with "enable_original_recipient = no".  File:
 	cleanup/cleanup_out_recipient.c.

diff -cr /var/tmp/postfix-2.3.9/src/cleanup/cleanup_out_recipient.c ./src/cleanup/cleanup_out_recipient.c
*** /var/tmp/postfix-2.3.9/src/cleanup/cleanup_out_recipient.c	Thu Jan  5 19:22:04 2006
--- ./src/cleanup/cleanup_out_recipient.c	Sun May 20 12:29:53 2007
***************
*** 127,139 ****
       * Distinguish between different original recipient addresses that map
       * onto the same mailbox. The recipient will use our original recipient
       * message header to figure things out.
       */
  #define STREQ(x, y) (strcmp((x), (y)) == 0)
  
      if ((state->flags & CLEANUP_FLAG_MAP_OK) == 0
  	|| cleanup_virt_alias_maps == 0) {
! 	if (been_here(state->dups, "%s\n%d\n%s\n%s",
! 		      dsn_orcpt, dsn_notify, orcpt, recip) == 0) {
  	    if (dsn_notify)
  		cleanup_out_format(state, REC_TYPE_ATTR, "%s=%d",
  				   MAIL_ATTR_DSN_NOTIFY, dsn_notify);
--- 127,146 ----
       * Distinguish between different original recipient addresses that map
       * onto the same mailbox. The recipient will use our original recipient
       * message header to figure things out.
+      * 
+      * Postfix 2.2 compatibility: when ignoring differences in Postfix original
+      * recipient information, also ignore differences in DSN attributes. We
+      * do, however, keep the DSN attributes of the recipient that survives
+      * duplicate elimination.
       */
  #define STREQ(x, y) (strcmp((x), (y)) == 0)
  
      if ((state->flags & CLEANUP_FLAG_MAP_OK) == 0
  	|| cleanup_virt_alias_maps == 0) {
! 	if ((var_enable_orcpt ?
! 	     been_here(state->dups, "%s\n%d\n%s\n%s",
! 		       dsn_orcpt, dsn_notify, orcpt, recip) :
! 	     been_here_fixed(state->dups, recip)) == 0) {
  	    if (dsn_notify)
  		cleanup_out_format(state, REC_TYPE_ATTR, "%s=%d",
  				   MAIL_ATTR_DSN_NOTIFY, dsn_notify);
***************
*** 181,186 ****
--- 188,198 ----
       * notifications. The queue manager will flush the trace (and bounce)
       * logfile, possibly after it has generated its own success or failure
       * notification records.
+      * 
+      * Postfix 2.2 compatibility: when ignoring differences in Postfix original
+      * recipient information, also ignore differences in DSN attributes. We
+      * do, however, keep the DSN attributes of the recipient that survives
+      * duplicate elimination.
       */
      else {
  	RECIPIENT rcpt;
***************
*** 198,205 ****
  			  dsn_notify & ~DSN_NOTIFY_SUCCESS);
  	}
  	for (cpp = argv->argv; *cpp; cpp++) {
! 	    if (been_here(state->dups, "%s\n%d\n%s\n%s",
! 			  dsn_orcpt, dsn_notify, orcpt, *cpp) == 0) {
  		if (dsn_notify)
  		    cleanup_out_format(state, REC_TYPE_ATTR, "%s=%d",
  				       MAIL_ATTR_DSN_NOTIFY, dsn_notify);
--- 210,219 ----
  			  dsn_notify & ~DSN_NOTIFY_SUCCESS);
  	}
  	for (cpp = argv->argv; *cpp; cpp++) {
! 	    if ((var_enable_orcpt ?
! 		 been_here(state->dups, "%s\n%d\n%s\n%s",
! 			   dsn_orcpt, dsn_notify, orcpt, *cpp) :
! 		 been_here_fixed(state->dups, *cpp)) == 0) {
  		if (dsn_notify)
  		    cleanup_out_format(state, REC_TYPE_ATTR, "%s=%d",
  				       MAIL_ATTR_DSN_NOTIFY, dsn_notify);
